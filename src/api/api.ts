/* tslint:disable */
/* eslint-disable */
/**
 * MIPH Shop Public API
 * Public-facing API for the MIPH educational shop backend.  ## Highlights - Magic-link authentication (no passwords) - Catalog browsing with filters and pagination - Likes, cart sync, and checkout flows - Consistent error envelope `{ error: { code, message, details } }`  ## Conventions - Base path: `/api/v1` - JSON: camelCase - Monetary fields are floats (RUB) in API responses - Pagination: `page`, `perPage` with `total` and `totalPages` 
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface CartItemSchema {
    'variantId': string;
    'itemId': string;
    'slug': string;
    'title': string;
    'variantTitle': string;
    'sku': string;
    'qty': number;
    'unitPriceRub': string;
    'lineTotalRub': string;
    'available': boolean;
    'stock': number;
    'imageUrl': string | null;
}
export interface CartMergeResponse {
    'cart': CartSchema;
    'mergeWarnings': Array<CartMergeWarning>;
}
export interface CartMergeWarning {
    'variantId': string;
    'reason': string;
}
export interface CartQtyRequest {
    'qty': number;
}
export interface CartResponse {
    'cart': CartSchema;
}
export interface CartSchema {
    'id': string;
    'items': Array<CartItemSchema>;
    'totals': CartTotalsSchema;
    'updatedAt': string;
}
export interface CartTotalsSchema {
    'itemsCount': number;
    'subtotalRub': string;
}
export interface CategoryListResponse {
    'data': Array<CategorySchema>;
}
export interface CategorySchema {
    'id': string;
    'slug': string;
    'title': string;
    'parentId': string | null;
    'isActive': boolean;
    'sortRank': number;
}
export interface ContactPayload {
    'name': string;
    'phone': string;
    'email': string;
}
export interface CreateOrderPayload {
    'delivery': DeliveryPayload;
    'contact': ContactPayload;
    'comment'?: string | null;
}
export interface DeliveryPayload {
    'method': string;
    'address': { [key: string]: any; };
}
export interface HTTPValidationError {
    'detail'?: Array<ValidationError>;
}
export interface ItemDetailResponse {
    'item': ItemDetailSchema;
}
export interface ItemDetailSchema {
    'id': string;
    'slug': string;
    'title': string;
    'description': string;
    'brand': string | null;
    'isActive': boolean;
    'categories': Array<CategorySchema>;
    'tags': Array<TagSchema>;
    'images': Array<ItemImageSchema>;
    'variants': Array<VariantSchema>;
}
export interface ItemImageSchema {
    'id': string;
    'url': string;
    'alt': string | null;
    'sortOrder': number;
    'isMain': boolean;
}
export interface ItemListSchema {
    'id': string;
    'slug': string;
    'title': string;
    'shortDescription'?: string | null;
    'isActive': boolean;
    'mainImageUrl'?: string | null;
    'minPriceRub': string | null;
    'maxPriceRub': string | null;
    'hasStock': boolean;
    'categorySlugs': Array<string>;
    'tagSlugs': Array<string>;
}
export interface LocationInner {
}
export interface MagicConsumeRequest {
    'token': string;
    'profile'?: ProfilePayload | null;
    'mergeCart'?: MergeCartPayload | null;
}
export interface MagicConsumeResponse {
    'accessToken': string;
    'refreshToken': string;
    'user': UserSchema;
    'flowContext'?: { [key: string]: any; } | null;
    'cart'?: CartSchema | null;
}
export interface MagicLinkRequest {
    'email': string;
    'flowContext'?: { [key: string]: any; } | null;
    'cartSnapshot'?: { [key: string]: any; } | null;
}
export interface MergeCartItem {
    'variantId': string;
    'qty': number;
}
export interface MergeCartPayload {
    'mode': string;
    'items': Array<MergeCartItem>;
}
export interface OkResponse {
    'ok'?: boolean;
}
export interface OrderContactSchema {
    'name': string;
    'phone': string;
    'email': string;
}
export interface OrderDeliverySchema {
    'method': string;
    'address': { [key: string]: any; };
}
export interface OrderEventSchema {
    'id': string;
    'fromStatus': string | null;
    'toStatus': string;
    'note': string | null;
    'createdBy': string;
    'createdAt': string;
}
export interface OrderItemSchema {
    'id': string;
    'itemId': string;
    'variantId': string;
    'title': string;
    'variantTitle': string;
    'sku': string;
    'unitPriceRub': string;
    'qty': number;
    'lineTotalRub': string;
}
export interface OrderResponse {
    'order': OrderSchema;
}
export interface OrderSchema {
    'id': string;
    'status': string;
    'subtotalRub': string;
    'deliveryRub': string;
    'totalRub': string;
    'placedAt': string;
    'items': Array<OrderItemSchema>;
    'delivery': OrderDeliverySchema;
    'contact': OrderContactSchema;
    'events': Array<OrderEventSchema>;
}
export interface PaginatedResponseItemListSchema {
    'data': Array<ItemListSchema>;
    'page'?: number;
    'perPage'?: number;
    'total': number;
    'totalPages': number;
}
export interface PaginatedResponseOrderSchema {
    'data': Array<OrderSchema>;
    'page'?: number;
    'perPage'?: number;
    'total': number;
    'totalPages': number;
}
export interface Pricemaxrub {
}
export interface Priceminrub {
}
export interface ProfilePayload {
    'name': string;
    'phone': string;
}
export interface RefreshTokenRequest {
    'refreshToken': string;
}
export interface RefreshTokenResponse {
    'accessToken': string;
    'refreshToken': string;
}
export interface TagListResponse {
    'data': Array<TagSchema>;
}
export interface TagSchema {
    'id': string;
    'slug': string;
    'title': string;
    'isActive': boolean;
}
export interface UserResponse {
    'user': UserSchema;
}
export interface UserSchema {
    'id': string;
    'email': string;
    'name': string;
    'phone': string | null;
    'isActive': boolean;
    'createdAt': string;
}
export interface UserUpdateSchema {
    'name'?: string | null;
    'phone'?: string | null;
}
export interface ValidationError {
    'loc': Array<LocationInner>;
    'msg': string;
    'type': string;
}
export interface VariantSchema {
    'id': string;
    'sku': string;
    'title': string;
    'attributes': { [key: string]: any; };
    'priceRub': string;
    'compareAtPriceRub': string | null;
    'stock': number;
    'isActive': boolean;
}

/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Consume Magic Link
         * @param {MagicConsumeRequest} magicConsumeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeMagicLinkApiV1AuthMagicConsumePost: async (magicConsumeRequest: MagicConsumeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'magicConsumeRequest' is not null or undefined
            assertParamExists('consumeMagicLinkApiV1AuthMagicConsumePost', 'magicConsumeRequest', magicConsumeRequest)
            const localVarPath = `/api/v1/auth/magic/consume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(magicConsumeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutApiV1AuthLogoutPost: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('logoutApiV1AuthLogoutPost', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenApiV1AuthRefreshPost: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshTokenApiV1AuthRefreshPost', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Magic Link
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestMagicLinkApiV1AuthMagicRequestPost: async (magicLinkRequest: MagicLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'magicLinkRequest' is not null or undefined
            assertParamExists('requestMagicLinkApiV1AuthMagicRequestPost', 'magicLinkRequest', magicLinkRequest)
            const localVarPath = `/api/v1/auth/magic/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(magicLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Consume Magic Link
         * @param {MagicConsumeRequest} magicConsumeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumeMagicLinkApiV1AuthMagicConsumePost(magicConsumeRequest: MagicConsumeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MagicConsumeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumeMagicLinkApiV1AuthMagicConsumePost(magicConsumeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.consumeMagicLinkApiV1AuthMagicConsumePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutApiV1AuthLogoutPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutApiV1AuthLogoutPost(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logoutApiV1AuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTokenApiV1AuthRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshTokenApiV1AuthRefreshPost(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshTokenApiV1AuthRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request Magic Link
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestMagicLinkApiV1AuthMagicRequestPost(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestMagicLinkApiV1AuthMagicRequestPost(magicLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.requestMagicLinkApiV1AuthMagicRequestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Consume Magic Link
         * @param {MagicConsumeRequest} magicConsumeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeMagicLinkApiV1AuthMagicConsumePost(magicConsumeRequest: MagicConsumeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MagicConsumeResponse> {
            return localVarFp.consumeMagicLinkApiV1AuthMagicConsumePost(magicConsumeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutApiV1AuthLogoutPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<OkResponse> {
            return localVarFp.logoutApiV1AuthLogoutPost(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenApiV1AuthRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshTokenApiV1AuthRefreshPost(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Magic Link
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestMagicLinkApiV1AuthMagicRequestPost(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<OkResponse> {
            return localVarFp.requestMagicLinkApiV1AuthMagicRequestPost(magicLinkRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Consume Magic Link
     * @param {MagicConsumeRequest} magicConsumeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public consumeMagicLinkApiV1AuthMagicConsumePost(magicConsumeRequest: MagicConsumeRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).consumeMagicLinkApiV1AuthMagicConsumePost(magicConsumeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutApiV1AuthLogoutPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logoutApiV1AuthLogoutPost(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Token
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshTokenApiV1AuthRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshTokenApiV1AuthRefreshPost(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Magic Link
     * @param {MagicLinkRequest} magicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestMagicLinkApiV1AuthMagicRequestPost(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).requestMagicLinkApiV1AuthMagicRequestPost(magicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CartApi - axios parameter creator
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCartApiV1MeCartClearPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/me/cart/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Cart Item
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCartItemApiV1MeCartItemsVariantIdDelete: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('deleteCartItemApiV1MeCartItemsVariantIdDelete', 'variantId', variantId)
            const localVarPath = `/api/v1/me/cart/items/{variant_id}`
                .replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartApiV1MeCartGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/me/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge Cart
         * @param {MergeCartPayload} mergeCartPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeCartApiV1MeCartMergePost: async (mergeCartPayload: MergeCartPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mergeCartPayload' is not null or undefined
            assertParamExists('mergeCartApiV1MeCartMergePost', 'mergeCartPayload', mergeCartPayload)
            const localVarPath = `/api/v1/me/cart/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeCartPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Cart Item
         * @param {string} variantId 
         * @param {CartQtyRequest} cartQtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCartItemApiV1MeCartItemsVariantIdPut: async (variantId: string, cartQtyRequest: CartQtyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('updateCartItemApiV1MeCartItemsVariantIdPut', 'variantId', variantId)
            // verify required parameter 'cartQtyRequest' is not null or undefined
            assertParamExists('updateCartItemApiV1MeCartItemsVariantIdPut', 'cartQtyRequest', cartQtyRequest)
            const localVarPath = `/api/v1/me/cart/items/{variant_id}`
                .replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cartQtyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clear Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearCartApiV1MeCartClearPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearCartApiV1MeCartClearPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.clearCartApiV1MeCartClearPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Cart Item
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCartItemApiV1MeCartItemsVariantIdDelete(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCartItemApiV1MeCartItemsVariantIdDelete(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.deleteCartItemApiV1MeCartItemsVariantIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCartApiV1MeCartGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCartApiV1MeCartGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.getCartApiV1MeCartGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Merge Cart
         * @param {MergeCartPayload} mergeCartPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeCartApiV1MeCartMergePost(mergeCartPayload: MergeCartPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartMergeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeCartApiV1MeCartMergePost(mergeCartPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.mergeCartApiV1MeCartMergePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Cart Item
         * @param {string} variantId 
         * @param {CartQtyRequest} cartQtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCartItemApiV1MeCartItemsVariantIdPut(variantId: string, cartQtyRequest: CartQtyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCartItemApiV1MeCartItemsVariantIdPut(variantId, cartQtyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.updateCartItemApiV1MeCartItemsVariantIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CartApi - factory interface
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * 
         * @summary Clear Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCartApiV1MeCartClearPost(options?: RawAxiosRequestConfig): AxiosPromise<CartResponse> {
            return localVarFp.clearCartApiV1MeCartClearPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Cart Item
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCartItemApiV1MeCartItemsVariantIdDelete(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<CartResponse> {
            return localVarFp.deleteCartItemApiV1MeCartItemsVariantIdDelete(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartApiV1MeCartGet(options?: RawAxiosRequestConfig): AxiosPromise<CartResponse> {
            return localVarFp.getCartApiV1MeCartGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge Cart
         * @param {MergeCartPayload} mergeCartPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeCartApiV1MeCartMergePost(mergeCartPayload: MergeCartPayload, options?: RawAxiosRequestConfig): AxiosPromise<CartMergeResponse> {
            return localVarFp.mergeCartApiV1MeCartMergePost(mergeCartPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Cart Item
         * @param {string} variantId 
         * @param {CartQtyRequest} cartQtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCartItemApiV1MeCartItemsVariantIdPut(variantId: string, cartQtyRequest: CartQtyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CartResponse> {
            return localVarFp.updateCartItemApiV1MeCartItemsVariantIdPut(variantId, cartQtyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CartApi - object-oriented interface
 */
export class CartApi extends BaseAPI {
    /**
     * 
     * @summary Clear Cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public clearCartApiV1MeCartClearPost(options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).clearCartApiV1MeCartClearPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Cart Item
     * @param {string} variantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCartItemApiV1MeCartItemsVariantIdDelete(variantId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).deleteCartItemApiV1MeCartItemsVariantIdDelete(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCartApiV1MeCartGet(options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).getCartApiV1MeCartGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merge Cart
     * @param {MergeCartPayload} mergeCartPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mergeCartApiV1MeCartMergePost(mergeCartPayload: MergeCartPayload, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).mergeCartApiV1MeCartMergePost(mergeCartPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Cart Item
     * @param {string} variantId 
     * @param {CartQtyRequest} cartQtyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCartItemApiV1MeCartItemsVariantIdPut(variantId: string, cartQtyRequest: CartQtyRequest, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).updateCartItemApiV1MeCartItemsVariantIdPut(variantId, cartQtyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CatalogApi - axios parameter creator
 */
export const CatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Item Detail
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemDetailApiV1ItemsSlugGet: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getItemDetailApiV1ItemsSlugGet', 'slug', slug)
            const localVarPath = `/api/v1/items/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoriesApiV1CategoriesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {string | null} [q] 
         * @param {string | null} [category] 
         * @param {string | null} [tags] 
         * @param {Priceminrub | null} [priceMinRub] 
         * @param {Pricemaxrub | null} [priceMaxRub] 
         * @param {boolean | null} [inStock] 
         * @param {string | null} [sort] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiV1ItemsGet: async (q?: string | null, category?: string | null, tags?: string | null, priceMinRub?: Priceminrub | null, priceMaxRub?: Pricemaxrub | null, inStock?: boolean | null, sort?: string | null, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (priceMinRub !== undefined) {
                for (const [key, value] of Object.entries(priceMinRub)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (priceMaxRub !== undefined) {
                for (const [key, value] of Object.entries(priceMaxRub)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (inStock !== undefined) {
                localVarQueryParameter['inStock'] = inStock;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagsApiV1TagsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogApi - functional programming interface
 */
export const CatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Item Detail
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemDetailApiV1ItemsSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemDetailApiV1ItemsSlugGet(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.getItemDetailApiV1ItemsSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategoriesApiV1CategoriesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategoriesApiV1CategoriesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.listCategoriesApiV1CategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {string | null} [q] 
         * @param {string | null} [category] 
         * @param {string | null} [tags] 
         * @param {Priceminrub | null} [priceMinRub] 
         * @param {Pricemaxrub | null} [priceMaxRub] 
         * @param {boolean | null} [inStock] 
         * @param {string | null} [sort] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiV1ItemsGet(q?: string | null, category?: string | null, tags?: string | null, priceMinRub?: Priceminrub | null, priceMaxRub?: Pricemaxrub | null, inStock?: boolean | null, sort?: string | null, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseItemListSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiV1ItemsGet(q, category, tags, priceMinRub, priceMaxRub, inStock, sort, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.listItemsApiV1ItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagsApiV1TagsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTagsApiV1TagsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.listTagsApiV1TagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CatalogApi - factory interface
 */
export const CatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Item Detail
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemDetailApiV1ItemsSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemDetailResponse> {
            return localVarFp.getItemDetailApiV1ItemsSlugGet(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoriesApiV1CategoriesGet(options?: RawAxiosRequestConfig): AxiosPromise<CategoryListResponse> {
            return localVarFp.listCategoriesApiV1CategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {string | null} [q] 
         * @param {string | null} [category] 
         * @param {string | null} [tags] 
         * @param {Priceminrub | null} [priceMinRub] 
         * @param {Pricemaxrub | null} [priceMaxRub] 
         * @param {boolean | null} [inStock] 
         * @param {string | null} [sort] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiV1ItemsGet(q?: string | null, category?: string | null, tags?: string | null, priceMinRub?: Priceminrub | null, priceMaxRub?: Pricemaxrub | null, inStock?: boolean | null, sort?: string | null, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseItemListSchema> {
            return localVarFp.listItemsApiV1ItemsGet(q, category, tags, priceMinRub, priceMaxRub, inStock, sort, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagsApiV1TagsGet(options?: RawAxiosRequestConfig): AxiosPromise<TagListResponse> {
            return localVarFp.listTagsApiV1TagsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogApi - object-oriented interface
 */
export class CatalogApi extends BaseAPI {
    /**
     * 
     * @summary Get Item Detail
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getItemDetailApiV1ItemsSlugGet(slug: string, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getItemDetailApiV1ItemsSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCategoriesApiV1CategoriesGet(options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).listCategoriesApiV1CategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {string | null} [q] 
     * @param {string | null} [category] 
     * @param {string | null} [tags] 
     * @param {Priceminrub | null} [priceMinRub] 
     * @param {Pricemaxrub | null} [priceMaxRub] 
     * @param {boolean | null} [inStock] 
     * @param {string | null} [sort] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiV1ItemsGet(q?: string | null, category?: string | null, tags?: string | null, priceMinRub?: Priceminrub | null, priceMaxRub?: Pricemaxrub | null, inStock?: boolean | null, sort?: string | null, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).listItemsApiV1ItemsGet(q, category, tags, priceMinRub, priceMaxRub, inStock, sort, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listTagsApiV1TagsGet(options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).listTagsApiV1TagsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthApiV1HealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthApiV1HealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthApiV1HealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthApiV1HealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthApiV1HealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthApiV1HealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthApiV1HealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthApiV1HealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LikesApi - axios parameter creator
 */
export const LikesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Like
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLikeApiV1MeLikesItemIdPost: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('addLikeApiV1MeLikesItemIdPost', 'itemId', itemId)
            const localVarPath = `/api/v1/me/likes/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Like
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLikeApiV1MeLikesItemIdDelete: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteLikeApiV1MeLikesItemIdDelete', 'itemId', itemId)
            const localVarPath = `/api/v1/me/likes/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Likes
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikesApiV1MeLikesGet: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/me/likes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikesApi - functional programming interface
 */
export const LikesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LikesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Like
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLikeApiV1MeLikesItemIdPost(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLikeApiV1MeLikesItemIdPost(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikesApi.addLikeApiV1MeLikesItemIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Like
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLikeApiV1MeLikesItemIdDelete(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLikeApiV1MeLikesItemIdDelete(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikesApi.deleteLikeApiV1MeLikesItemIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Likes
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLikesApiV1MeLikesGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseItemListSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLikesApiV1MeLikesGet(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikesApi.listLikesApiV1MeLikesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LikesApi - factory interface
 */
export const LikesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LikesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Like
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLikeApiV1MeLikesItemIdPost(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.addLikeApiV1MeLikesItemIdPost(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Like
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLikeApiV1MeLikesItemIdDelete(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteLikeApiV1MeLikesItemIdDelete(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Likes
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikesApiV1MeLikesGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseItemListSchema> {
            return localVarFp.listLikesApiV1MeLikesGet(page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LikesApi - object-oriented interface
 */
export class LikesApi extends BaseAPI {
    /**
     * 
     * @summary Add Like
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addLikeApiV1MeLikesItemIdPost(itemId: string, options?: RawAxiosRequestConfig) {
        return LikesApiFp(this.configuration).addLikeApiV1MeLikesItemIdPost(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Like
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteLikeApiV1MeLikesItemIdDelete(itemId: string, options?: RawAxiosRequestConfig) {
        return LikesApiFp(this.configuration).deleteLikeApiV1MeLikesItemIdDelete(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Likes
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listLikesApiV1MeLikesGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return LikesApiFp(this.configuration).listLikesApiV1MeLikesGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeApi - axios parameter creator
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeApiV1MeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeApiV1MePatch: async (userUpdateSchema: UserUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateSchema' is not null or undefined
            assertParamExists('updateMeApiV1MePatch', 'userUpdateSchema', userUpdateSchema)
            const localVarPath = `/api/v1/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeApiV1MeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeApiV1MeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.getMeApiV1MeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeApiV1MePatch(userUpdateSchema: UserUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeApiV1MePatch(userUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.updateMeApiV1MePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeApi - factory interface
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeApiV1MeGet(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getMeApiV1MeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeApiV1MePatch(userUpdateSchema: UserUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.updateMeApiV1MePatch(userUpdateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeApi - object-oriented interface
 */
export class MeApi extends BaseAPI {
    /**
     * 
     * @summary Get Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMeApiV1MeGet(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).getMeApiV1MeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Me
     * @param {UserUpdateSchema} userUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateMeApiV1MePatch(userUpdateSchema: UserUpdateSchema, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).updateMeApiV1MePatch(userUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrderApiV1MeOrdersOrderIdCancelPost: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('cancelOrderApiV1MeOrdersOrderIdCancelPost', 'orderId', orderId)
            const localVarPath = `/api/v1/me/orders/{order_id}/cancel`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Order
         * @param {CreateOrderPayload} createOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderApiV1MeOrdersPost: async (createOrderPayload: CreateOrderPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderPayload' is not null or undefined
            assertParamExists('createOrderApiV1MeOrdersPost', 'createOrderPayload', createOrderPayload)
            const localVarPath = `/api/v1/me/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderApiV1MeOrdersOrderIdGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderApiV1MeOrdersOrderIdGet', 'orderId', orderId)
            const localVarPath = `/api/v1/me/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Orders
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrdersApiV1MeOrdersGet: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/me/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulate Payment
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost', 'orderId', orderId)
            const localVarPath = `/api/v1/me/orders/{order_id}/simulate-payment`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrderApiV1MeOrdersOrderIdCancelPost(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrderApiV1MeOrdersOrderIdCancelPost(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.cancelOrderApiV1MeOrdersOrderIdCancelPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Order
         * @param {CreateOrderPayload} createOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderApiV1MeOrdersPost(createOrderPayload: CreateOrderPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderApiV1MeOrdersPost(createOrderPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.createOrderApiV1MeOrdersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderApiV1MeOrdersOrderIdGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderApiV1MeOrdersOrderIdGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrderApiV1MeOrdersOrderIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Orders
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrdersApiV1MeOrdersGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOrderSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrdersApiV1MeOrdersGet(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.listOrdersApiV1MeOrdersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulate Payment
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrderApiV1MeOrdersOrderIdCancelPost(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.cancelOrderApiV1MeOrdersOrderIdCancelPost(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Order
         * @param {CreateOrderPayload} createOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderApiV1MeOrdersPost(createOrderPayload: CreateOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.createOrderApiV1MeOrdersPost(createOrderPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderApiV1MeOrdersOrderIdGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.getOrderApiV1MeOrdersOrderIdGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Orders
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrdersApiV1MeOrdersGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOrderSchema> {
            return localVarFp.listOrdersApiV1MeOrdersGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulate Payment
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @summary Cancel Order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelOrderApiV1MeOrdersOrderIdCancelPost(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).cancelOrderApiV1MeOrdersOrderIdCancelPost(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Order
     * @param {CreateOrderPayload} createOrderPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrderApiV1MeOrdersPost(createOrderPayload: CreateOrderPayload, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).createOrderApiV1MeOrdersPost(createOrderPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrderApiV1MeOrdersOrderIdGet(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrderApiV1MeOrdersOrderIdGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Orders
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listOrdersApiV1MeOrdersGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).listOrdersApiV1MeOrdersGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulate Payment
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).simulatePaymentApiV1MeOrdersOrderIdSimulatePaymentPost(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}



